# Since kadeploy3 is not properly namespaced,
# everything is included into Kernel... yeah for name collisions!
# Depends kadeploy-common
$LOAD_PATH.unshift '/usr/local/kadeploy3/src/lib'

# Kadeploy libs
require 'config'
require 'error'

require 'tempfile'
require 'thread'
require 'drb'
require 'socket'
require 'timeout'
require 'uri'
require 'logger'

require 'eventmachine'

module ConfigInformation
  class Config
    def Config.load_client_config_file
      # undef load_client_config_file
      # since we don't have/need a client configuration file
      # on the api-servers.
      #
      # See configuration (g5k-api/config/defaults.yml)
      kadeploy_uri = URI.parse(Kadeploy.config)
      {
        "default" => "idontgiveashit",
        "idontgiveashit" => [kadeploy_uri.host, kadeploy_uri.port]
      }
    end
  end
end

# Disable reverse lookup to prevent lag in case of DNS failure
Socket.do_not_reverse_lookup = true

module Kadeploy
  DEFAULT_TIMEOUT = 10

  class << self
    attr_accessor :config

    def logger=(logger)
      @logger = logger
    end

    def logger
      @logger ||= Logger.new(STDERR)
    end

    def redirect_stdout
      old_stdout = $stdout
      output_file = Tempfile.new("stdout_output")
      begin
        # redirect stdout to the file
        $stdout = output_file
        yield output_file
      ensure
        $stdout = old_stdout
      end
    end # def redirect_stdout
  end

  class Error < StandardError
    class << self
      def set_default_message(msg)
        class_eval { define_method(:default_message) { msg } }
      end
    end

    def to_s
      default = super
      (default == self.class.name && self.default_message) ? self.default_message : default
    end

    set_default_message "An unknown error occured. Please report to your administrator"
  end
  class InvalidDeployment < Error
    set_default_message "Your deployment contains invalid options or you do not have the rights on the nodes"
  end


  class Server

    include EM::Deferrable

    attr_reader :handler, :options, :exception

    def initialize(options = {})
      @options = options
      @handler = nil
    end

    def connect!(options = {})
      DRb.start_service
      @handler = DRbObject.new(nil, Kadeploy.config)
      if block_given?
        begin
          yield self
        ensure
          disconnect!
        end
      else
        self
      end
    end

    def disconnect!
      @handler = nil
      DRb.stop_service
    end

    def method_missing(method, *args)
      if method =~ /^async_(.+)/
        # reset exception variable
        @exception = nil
        # set up timeout
        timeout(options[:timeout] || Kadeploy::DEFAULT_TIMEOUT)
        # define the operation to launch
        operation = proc {
          begin
            [ok=true, connect!.send($1.to_sym, *args)]
          rescue Exception => e
            @exception = e
            Kadeploy.logger.error "Error when executing #{method}: #{e.class.name} - #{e.message}: #{e.backtrace.join("; ")}"
            ok=false
          ensure
            disconnect!
          end
        }
        # succeed or fail depending on the result of the scheduled operation
        callback = proc { |ok, *args|
          ok ? succeed(*args) : fail
        }
        # schedule the operation in a Deferrable.
        EM.defer(operation, callback)
        self
      else
        super(method, *args)
      end
    end

    # Submit a new deployment on the kadpeloy server
    # Returns true
    def submit!(args, options = {})
      ARGV.clear
      ARGV.push(*args)
      config = nil
      # Capture STDOUT so that we can get the errors generated by kadeploy
      Kadeploy.redirect_stdout do |stdout|
        config = ConfigInformation::Config.load_kadeploy_exec_specific()
        if config.nil?
          stdout.rewind; output = stdout.read.split("\n"); stdout.close
          raise InvalidDeployment, output[0]
        else
          config.true_user = options[:user]
        end
      end
      workflow_uid, error = handler.run("kadeploy_async", config, nil, nil)
      if workflow_uid.nil?
        case error
        when KadeployAsyncError::NODES_DISCARDED
          raise InvalidDeployment, "The nodes are already involved in a deployment, hence your deployment cannot be run"
        when KadeployAsyncError::NO_RIGHT_TO_DEPLOY
          raise InvalidDeployment, "You do not have the right to deploy on the nodes"
        when KadeployAsyncError::UNKNOWN_NODE_IN_SINGULARITY_FILE
          raise InvalidDeployment, "Unknown node in singularity file"
        when KadeployAsyncError::NODE_NOT_EXIST
          raise InvalidDeployment, "One of the node does not exist"
        when KadeployAsyncError::VLAN_MGMT_DISABLED
          raise InvalidDeployment, "VLAN management is disabled"
        when KadeployAsyncError::LOAD_ENV_FROM_FILE_ERROR
          raise InvalidDeployment, "Cannot load the environment from the given file"
        when KadeployAsyncError::LOAD_ENV_FROM_DB_ERROR
          raise InvalidDeployment, "Cannot load the environment from the database"
        when KadeployAsyncError::NO_ENV_CHOSEN
          raise InvalidDeployment, "You must select an environment to deploy"
        else
          raise Error, "An error occured when submitting your deployment (#{error.inspect}). Please report to your administrator"
        end
      else
        workflow_uid
      end
    end # def launch!


    # Get the status of a deployment on the kadeploy server
    # Returns an array of [status, results, output].
    # <tt>:status</tt> being one of: :processing, :terminated, :canceled, :error
    # <tt>results</tt> being a hash as returned by the results! method.
    # <tt>output</tt> being a string.
    #
    # This method automatically frees the deployment on the kadeploy-server if no longer processing.
    #
    def touch!(uid)
      workflow_uid = uid
      ended        = handler.async_deploy_ended?(workflow_uid)
      Kadeploy.logger.debug "Deployment ##{workflow_uid}#{ended ? "" : " NOT"} ended."
      case ended
      when TrueClass
        # OK, deployment has ended, let's see if there were any errors:
        error = handler.async_deploy_file_error?(workflow_uid)
        if error == FetchFileError::NO_ERROR
          results = results!(uid)
          free!(uid)
          [
            :terminated,
            results,
            nil
          ]
        else
          output = case error
          when FetchFileError::INVALID_ENVIRONMENT_TARBALL
            "Your environment tarball cannot be fetched"
          when FetchFileError::INVALID_PREINSTALL
            "Your pre-install cannot be fetched"
          when FetchFileError::PREINSTALL_TOO_BIG
            "Your pre-install is too big"
          when FetchFileError::INVALID_POSTINSTALL
            "Your post-install cannot be fetched"
          when FetchFileError::POSTINSTALL_TOO_BIG
            "Your post-install is too big"
          when FetchFileError::INVALID_KEY
            "Your key cannot be fetched"
          when FetchFileError::INVALID_CUSTOM_FILE
            "Your custom file cannot be fetched"
          when FetchFileError::INVALID_PXE_FILE
            "Your PXE file cannot be fetched"
          when FetchFileError::TEMPFILE_CANNOT_BE_CREATED_IN_CACHE
            "An error occurred when fetching your environment. Kadeploy3 cache is probably full"
          when FetchFileError::FILE_CANNOT_BE_MOVED_IN_CACHE
            "An error occurred when fetching your environment. The tarball file cannot be moved to Kadeploy3 cache"
          else
            "An unknown error occured (#{error}). Please contact your administrator"
          end
          Kadeploy.logger.info "Deployment ##{workflow_uid} encountered an error (#{error.inspect}): #{output}"
          free!(uid)
          [:error, nil, output]
        end
      when NilClass
        # Deployment no longer exists, this is probably not expected
        [:canceled, nil, "Deployment no longer exists on the Kadeploy server"]
      else
        # Deployment still in progress
        [:processing, nil, nil]
      end
    end # def status!

    # Get the results of a deployment
    # Must be called ONLY IF the status of the deployment is :terminated
    def results!(uid)
      fields_to_reject = %w{cmd}
      fields_to_convert = {
        "last_cmd_exit_status" => Proc.new{|value| value.to_i},
        "last_cmd_stderr" => Proc.new{|value| value[0..100]},
        "last_cmd_stdout" => Proc.new{|value| value[0..100]}
      }
      h = {}
       # Returns a hash, ex:
      # {"nodes_ok"=>{"paraquad-20.rennes.grid5000.fr"=>{"last_cmd_stdout"=>"", "cmd"=>"#<Nodes::NodeCmd:0x1038ce020>", "last_cmd_stderr"=>"", "cluster"=>"paraquad", "ip"=>"131.254.202.40", "last_cmd_exit_status"=>"0", "current_step"=>nil, "state"=>"OK"}}, "nodes_ko"=>{}}
      raw = handler.async_deploy_get_results(uid) || {}
      raw.values.each do |nodes|
        nodes.each do |node_fqdn, value|
          value = value.reject{|k,v| fields_to_reject.include?(k)}
          fields_to_convert.each do |field, method|
            value[field] = method.call(value[field]) if value[field]
          end
          h[node_fqdn] = value
        end
      end
      h
    end # def results!

    # Free the memory associated to the deployment on the kadeploy server
    def free!(uid)
      begin
        handler.async_deploy_free(uid)
      rescue Exception => e
        # Catch but ignore any exception that can be raised when freeing
        Kadeploy.logger.warn "Tried to free #{uid} => Received #{e.class.name} - #{e.message}: #{e.backtrace.join("; ")}"
      end
      true
    end # def free!


    # Delete a deployment on the kadeploy server
    def cancel!(uid)
      handler.async_deploy_kill(uid)
    end # def cancel!

  end # class Server
end # module Kadeploy
