# Since kadeploy3 is not properly namespaced, 
# everything is included into Kernel... yeah for name collisions!
$LOAD_PATH.unshift File.dirname(__FILE__)+'/kadeploy'

# Kadeploy libs
require 'config'
require 'error'

require 'tempfile'
require 'thread'
require 'drb'
require 'socket'
require 'timeout'
require 'uri'
require 'logger'

module ConfigInformation
  class Config
    def Config.load_client_config_file
      # undef load_client_config_file 
      # since we don't have/need a client configuration file 
      # on the api-servers
      kadeploy_uri = URI.parse(Kadeploy.config)
      {
        "default" => "idontgiveashit",
        "idontgiveashit" => [kadeploy_uri.host, kadeploy_uri.port]
      }
    end
  end
end

# Disable reverse lookup to prevent lag in case of DNS failure
Socket.do_not_reverse_lookup = true

module Kadeploy
  DEFAULT_TIMEOUT = 15
  
  class << self
    attr_accessor :config
    
    def connect!(options = {})
      DRb.start_service
      server = Server.new(config)
      if block_given?
        begin
          Timeout.timeout(options[:timeout] || DEFAULT_TIMEOUT) do
            yield server
          end
        ensure
          disconnect!
        end
      else
        server
      end
    end
    
    def disconnect!
      DRb.stop_service
    end
    
    def logger=(logger)
      @logger = logger
    end
    
    def logger
      @logger ||= Logger.new(STDERR)
    end
    
    def redirect_stdout
      old_stdout = $stdout
      output_file = Tempfile.new("stdout_output")
      begin 
        # redirect stdout to the file
        $stdout = output_file
        yield output_file
      ensure  
        $stdout = old_stdout
      end
    end # def redirect_stdout
  end
  
  class Error < StandardError
    class << self
      def set_default_message(msg)
        class_eval { define_method(:default_message) { msg } }
      end
    end
    
    def to_s
      default = super
      (default == self.class.name && self.default_message) ? self.default_message : default
    end

    set_default_message "An unknown error occured. Please report to your administrator"
  end
  class InvalidDeployment < Error
    set_default_message "Your deployment contains invalid options or you do not have the rights on the nodes"
  end
  
  
  class Server
    attr_reader :handler, :errors
    
    def initialize(uri)
      @errors = []
      @handler = DRbObject.new(nil, uri)
    end
    
    # Submit a new deployment on the kadpeloy server
    # Returns true
    def submit!(args, options = {})
      ARGV.clear
      ARGV.push(*args)
      config = nil
      # Capture STDOUT so that we can get the errors generated by kadeploy
      Kadeploy.redirect_stdout do |stdout|
        config = ConfigInformation::Config.load_kadeploy_exec_specific()
        if config.nil?
          stdout.rewind; output = stdout.read.split("\n"); stdout.close
          raise InvalidDeployment, output[0]
        else
          config.user = config.true_user = options[:user]
        end
      end
      workflow_uid, error = handler.run("kadeploy_async", config, nil, nil)
      if workflow_uid.nil?
        case error
        when KadeployAsyncError::NODES_DISCARDED
          raise InvalidDeployment, "All the nodes of your deployment have been discarded, hence your deployment cannot be run"
        when KadeployAsyncError::NO_RIGHT_TO_DEPLOY
          raise InvalidDeployment, "You do not have the right to deploy on the nodes"
        when KadeployAsyncError::UNKNOWN_NODE_IN_SINGULARITY_FILE
          raise InvalidDeployment, "Unknown node in singularity file"
        when KadeployAsyncError::NODE_NOT_EXIST
          raise InvalidDeployment, "One of the node does not exist"
        when KadeployAsyncError::VLAN_MGMT_DISABLED
          raise InvalidDeployment, "VLAN management is disabled"
        when KadeployAsyncError::LOAD_ENV_FROM_FILE_ERROR
          raise InvalidDeployment, "Cannot load the environment from the given file"
        when KadeployAsyncError::LOAD_ENV_FROM_DB_ERROR
          raise InvalidDeployment, "Cannot load the environment from the database"
        when KadeployAsyncError::NO_ENV_CHOSEN
          raise InvalidDeployment, "You must select an environment to deploy"
        else
          raise Error, "An error occured when submitting your deployment (#{error.inspect}). Please report to your administrator"
        end
      else
        workflow_uid
      end
    end # def launch!
    
    
    # Get the status of a deployment on the kadeploy server
    # Returns an array of [status, results].
    # <tt>:status</tt> being one of: :processing, :terminated, :canceled, :error
    # <tt>results</tt> being a hash as returned by the results! method.
    # 
    # This method automatically frees the deployment on the kadeploy-server if no longer processing.
    # 
    def touch!(uid)
      workflow_uid = uid
      ended        = handler.async_deploy_ended?(workflow_uid)
      Kadeploy.logger.debug "Deployment ##{workflow_uid}#{ended ? "" : " NOT"} ended."
      case ended
      when TrueClass
        # OK, deployment has ended, let's see if there were any errors:
        error = handler.async_deploy_file_error?(workflow_uid)
        if error == FetchFileError::NO_ERROR
          results = results!(uid)
          free!(uid)
          [
            :terminated,
            results
          ]
        else
          case error
          when FetchFileError::INVALID_ENVIRONMENT_TARBALL
            errors.push("Your environment tarball cannot be fetched")
          when FetchFileError::INVALID_PREINSTALL
            errors.push("Your pre-install cannot be fetched")
          when FetchFileError::PREINSTALL_TOO_BIG
            errors.push("Your pre-install is too big")
          when FetchFileError::INVALID_POSTINSTALL
            errors.push("Your post-install cannot be fetched")
          when FetchFileError::POSTINSTALL_TOO_BIG
            errors.push("Your post-install is too big")
          when FetchFileError::INVALID_KEY
            errors.push("Your key cannot be fetched")
          when FetchFileError::INVALID_CUSTOM_FILE
            errors.push("Your custom file cannot be fetched")
          when FetchFileError::INVALID_PXE_FILE
            errors.push("Your PXE file cannot be fetched")
          when FetchFileError::TEMPFILE_CANNOT_BE_CREATED_IN_CACHE
            errors.push("An error occurred when fetching your environment. Kadeploy3 cache is probably full")
          when FetchFileError::FILE_CANNOT_BE_MOVED_IN_CACHE
            errors.push("An error occurred when fetching your environment. The tarball file cannot be moved to Kadeploy3 cache")
          else
            errors.push("An unknown error occured (#{error}). Please contact your administrator")
          end
          Kadeploy.logger.info "Deployment ##{workflow_uid} encountered an error (#{error.inspect}): #{errors.join(" ")}"
          [:error, nil]
        end
      when NilClass
        # Deployment no longer exists, this is probably an error
        errors.push("Deployment no longer exists on the Kadeploy server")
        [:canceled, nil]
      else
        # Deployment still in progress
        [:processing, nil]
      end      
    end # def status!
    
    # Get the results of a deployment
    # Must be called ONLY IF the status of the deployment is :terminated
    def results!(uid)
      fields_to_reject = %w{cmd}
      fields_to_convert = {
        "last_cmd_exit_status" => Proc.new{|value| value.to_i},
        "last_cmd_stderr" => Proc.new{|value| value[0..100]},
        "last_cmd_stdout" => Proc.new{|value| value[0..100]}
      }
      h = {}
       # Returns a hash, ex:
      # {"nodes_ok"=>{"paraquad-20.rennes.grid5000.fr"=>{"last_cmd_stdout"=>"", "cmd"=>"#<Nodes::NodeCmd:0x1038ce020>", "last_cmd_stderr"=>"", "cluster"=>"paraquad", "ip"=>"131.254.202.40", "last_cmd_exit_status"=>"0", "current_step"=>nil, "state"=>"OK"}}, "nodes_ko"=>{}}
      raw = handler.async_deploy_get_results(uid) || {}
      raw.values.each do |nodes|
        nodes.each do |node_fqdn, value|
          value = value.reject{|k,v| fields_to_reject.include?(k)}
          fields_to_convert.each do |field, method|
            value[field] = method.call(value[field]) if value[field]
          end
          h[node_fqdn] = value
        end
      end
      h
    end # def results!
    
    # Free the memory associated to the deployment on the kadeploy server
    def free!(uid)
      handler.async_deploy_free(uid)
      true
    end # def free!
    
    
    # Delete a deployment on the kadeploy server
    def cancel!(uid)
      handler.async_deploy_kill(uid)
      true
    end # def cancel!
    
  end # class Server
end # module Kadeploy
